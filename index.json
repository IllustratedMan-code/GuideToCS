[
{
	"uri": "https://illustratedman-code.github.io/GuideToCS/intro-to-comp-systems/hard-vs-micro/",
	"title": "HardWiredVsMicroProgrammed;",
	"tags": [],
	"description": "",
	"content": "Intro Describes a \u0026ldquo;big Picture\u0026rdquo; of computer systems through an example of a \u0026ldquo;simple\u0026rdquo; computer. This computer is Big Endian (reads the leftmost (most significant) bit first)\nThe Basic Computer Two Principal functional parts  Data path section where processing occurs Control section decodes instructions and leaves control sequence for Data path section  Two types of control units  Hard wired controllers Micro programmed controllers  figure 1    Description of figure 1 Data Path Sections\n   Single 12-bit-wide bus\nexchanges information between pairs of registers\n     Registers + 256 X 12 bit RAM\ncontrolled by 16 control signals\n   Load(L) signals\nActive L clocks or loads bus contents into register on next rising pulse from the system clock\n     Enabled(E) signals\nActive E signal enables the tristate outputs of the register or makes contents of register available to bus\n     register tranfer from example\nContents of Register A to B\n Requires EA signal (contents of A can be read by bus) Requires LB signal (contents of bus can be moved into B)      Arithmetic-Logic-Unit (ALU) A circuit capable of adding or subtracting two 12 bit numbers When the first bit of the Accumulator(ACC) is 1 (Negative Flag) it is considered a negative number (represented using 2s compliment)\n Two input registers  Accumulator (ACC) Register B   Two control signals  Add (A) Subtract (S)    RAM memory    Registers\n   Memory Address Register (MAR)\nRegister where address from memory is temporarily stored\n     Memory Data Register (MDR)\nRegister where data (word) corresponding to the address in MAR is temporarily stored\n       Control Signals\n   Read (R)\ncopies Word stored in RAM at address specified by MAR to MDR\n     Write (W)\ncopies contents (Word) of MDR to RAM at address specified by MAR\n       Steps to write and read data to the RAM\n   Read\n 8-bit address is stored in register MAR Active R signal is supplied to the RAM Data is copied from RAM at address specified by MAR to MDR register       Write\n 8-bit address is stored in register MAR a Word is stored in register MDR Active W signal is supplied to RAM Data is copied from MDR to RAM at address specified by MAR       Note about I/O implementation\nIn this specific computer design, all I/O devices are memory mapped This means that several memory locations are reserved for the I/O devices writing and reading to these I/O devices works in the same way as any other location in the ram.\n    Program Counter (PC) Register    Increment Program Counter (IP) control signal\nWhen PC recieves an IP signal it increments contents of PC by 1\n     Instruction Register (IR)\nHolds the instruction that is about to be executed and provides opcode to the controller/sequencer\n  Computer\u0026rsquo;s Instruction Set A set of all instructions that the computer can process.\nInstruction A 12-bit word made up of a 4-bit opcode and an 8-bit operand address\noperation code (opcode) specifies the action to be taken by the computer\noperand The data that the opcode operates on. Located at a memory location specified by the 8 bit address in the instruction.\nTable 1   Table 1 description    Op-Code\nThe base 10 identity of the 4 bit code(in this computer) at the beginning of every instruction. Specifies the action that will be performed, such as loading, moving values. Not shown is the Fetch Instruction (an instruction used to load the next instruction) and can be thought of as having the opcode 0000, but it really doesn\u0026rsquo;t require one (in Hard-Wired)\n     Opcode are specified in assembly by the Mnemonic\nThe Mnemonic makes the assembly code much more human readable\n LDA (Load accumlulator(ACC)) is equivalent to op-code 0001 STA (Store ACC) is equivalent to op-code 0002 The codes 8(1000) - 15(1111) are all equivalent to the HLT Mnemonic       Register Transfers\nThis column shows how data is transferred from one register to another until the action specified by the opcode has been accomplished.\n LDA 00100010 is an example instruction LDA (Loads data from RAM to accumlulator register) by following the steps required to access data from RAM  MAR \u0026lt;\u0026ndash; IR moves (copies) the contents of the Instruction Register(IR) to the Memory Address Register MDR \u0026lt;\u0026ndash; RAM(MAR) moves the data at address specified by MAR to the MDR register ACC \u0026lt;\u0026ndash; MDR moves the contents of MDR to ACC ACC \u0026lt;\u0026ndash; RAM is then accomplished.         Active Control Signals\nThis column shows the signals that are required (power to signal pin) to perform the specified register transfers. Signal Pins are shown in Figure 1\n MAR \u0026lt;\u0026ndash; IR requires the EI (enable instruction register) and the LM (Load MAR) signals MDR \u0026lt;\u0026ndash; RAM(MAR) requires the R (read) signal    Hard-Wired Control Unit Figure 2   Description of Figure 2 Internal organization of a hard-wired control unit A hard wired version of our example computer. A control unit consists of a Ring counter, an instruction decoder, and a Control matrix\n   Instruction Register (IR)\nContains the current instruction (opcode + operand) The instruction register sends the Op-code (first 4 bits) to the instruction decoder. Each line to the Instruction Decoder represents a bit of the opcode.\n     Instruction Decoder\n Receives the opcode sent to it by the IR Interprets the opcode as a specific signal. Sends a signal to the control matrix corresponding to the opcode from the IR Each line to the Control matrix represents a different signal (a set of pins)  Figure 4\n     Negative Flag\nThe leading bit (\u0026ldquo;negative flag\u0026rdquo;) of the ACC register is fed into the control matrix allowing for Boolean logic within the control matrix.\n     Ring Counter\nSix Consecutive active signals that cycle continuously with every beat of the system clock\n Ring Pulse or Ring Counter Pulse When the signal becomes active (ring pulse T0 means when T0 becomes active)  A useful article about ring counters Table 2\n     Control Matrix\nMost important part of the control unit The control matrix sends out signals to every register in the computer as shown in Figure 1 and facilitates all of the instructions listed in Table 1 using those signals.\n  Figure 3 A visualization of the inner workings of the ring counter Figure 4 A visualization of the inner working of the Instruction Decoder. Shows how each opcode corresponds to an output line. Table 2 Times at which each Control Signal must be active in order to execute the hard-wired Basic Computer\u0026rsquo;s instructions. Fetch instruction The fetch instruction is executed every time the Ring Counter loops. This facilitates the next instruction being sent to the Control unit. This instruction is actually executed during the same ring counter loop as any other instructions. So when an opcode is sent to the control matrix, fetch is executed And whatever instruction is specified by the opcode. This ensures that the next instruction is fetched by the end of the ring counter loop.\nHow does the computer choose which signals to use for an opcode?   LM signal for example, the signal to load data into MAR according to Figure 1 LM has a T3 on the LDA and SDA Rows and a T0 on the Fetch row\n An AND operation is performed between each Tx and its instruction signal (in the column). An OR operation is performed between each AND operation. As this can be represented with bits (1s or 0s) These operations can be simplified to an arithmetic expression LM = T0 + T3*LDA + T3*STA. T0 does not need an AND because the fetch instruction is executed every ring counter cycle. According to the expression: LM is active when T0 is active and when T3 and (LDA or STA) is active    JN(jump negative) Row All Tx in this row have an AND operation with the value of NF(Negative Flag) as well as the instruction signal JN. This provides another level of conditional logic based on the value of the ACC negative flag. The arithmetic expression for the LP column is: LP = T3*JN*NF + T3*JMP(Jump)\n  A list of all the conditional expressions for the control signals (where * = AND, + = OR) is located in Figure 6\n  Figure 5 A hard wired example of how the control matrix would work Figure 6 A list of possible conditional expressions for the example computer. Micro-programmed Control Unit In the Hard Wired control unit example, the signals that come from the control matrix do so because of an actual circuit that is wired to perform the conditional logic shown in Figure 5. In a Micro-Programmed Control Unit an opcode is sent to the Control unit where it fetches a list of Micro-Instructions that together perform the instruction from a memory. The control unit can be thought of as a Computer within a computer.\nMicro-routine A micro-routine is a set of Micro-Instructions that implement an instruction.\nMicro-Instruction Similar to the instruction in a hard-wired computer, the micro-instruction operates on the hard wired circuits within the control unit. A micro-instruction is composed of bits that might correspond to a control signal(LM for example).\nFigure 7 A block diagram of an example micro-programmed control unit. 32 X 24 Control ROM(Read-only memory)  32 24-bit long Micro-Instructions can be stored in the ROM memory A Word is 24 bits in the context of the micro-programmable Control unit Micro-instructions in this example are composed of two fields  16-bit control signal field Each bit corresponds to a control signal 8-bit next-address field address(in ROM) of next micro-instruction to be executed. which permits additional Boolean logic shown in Figure 8.   Micro-instructions(Words) from the Control ROM are fed into the micro-instruction register.  24-bit Micro-instruction Register  analogous to the external computer\u0026rsquo;s Instruction Register. 16 signal lines are the same as the lines coming from the control matrix in Figure 2 and are connected to the signal pins shown in Figure 1. triggered by a falling clock edge See this article about signal edges  micro-counter register  Analogous to the external computer\u0026rsquo;s Program counter Register recieves input from the Multiplexer triggered by a rising clock edge. signal edges  Multiplexer (data selector) Chooses between 3 values to send to the micro-counter register\n Output of Address ROM Output from Current Address Incrementer Address stored in next-address field of the current micro-instruction (CRJA) The conditional logic is shown in the description of Figure 8  16 X 5 Address ROM Fed by outer computer\u0026rsquo;s Instruction Register. The contents of the Instruction Register can be found in Table 3\n maps opcode of external computer\u0026rsquo;s instruction to starting address of corresponding micro-routine. The first Micro-Instruction of the routine Address zero of Address ROM contains address of fetch routine in the Control ROM Other addresses in ROM correspond to the opcodes(external computer) in Table 1 addresses are of micro-routines in Control ROM  Note about signal edges The micro-counter is triggered by a rising clock edge (along with all operations in data path in Figure 1). The Micro-instruction register is triggered by a falling clock edge. In a series of steps:\n micro-counter is triggered (positive edge), presenting the new Micro-instruction address to the control ROM Previous micro-instruction is converted to signals which are sent to external system control ROM presents micro-instruction Word to micro-instruction register Micro-instruction register is triggered (negative edge) causing it to receive the micro-instruction Word  Table 3 Mapping of Op-codes to the contents of the Address ROM in the Control Unit Example using the ADD instruction ADD instruction has the 3 opcode which maps to the 09 micro-routine start address. The address is then goes to the multiplexer -\u0026gt; micro-counter -\u0026gt; Control ROM -\u0026gt; Micro-instruction register\nFigure 8 Next address field of the micro-instruction register.  CD is condition bit when CD is 1 (MAP is zero) the multiplexer\u0026rsquo;s select lines produce a 00 or a 10 (binary) based on the Negative Flag of the ACC register (of external computer). 00 00 selects incrementer address, 10 selects CRJA address MAP causes next microinstruction to be obtained from address ROM When the MAP bit is 1 (Multiplexer\u0026rsquo;s select line produce a 01(binary) (selects the address ROM)) HLT stops clock, terminating execution of activities in the entire computer CRJA (5 bits) is the control ROM jump address field (next-address field). When (CD, MAP is 0) then multiplexer\u0026rsquo;s select lines produce a 10(binary), selecting the CRJA field as the address to the next micro-instruction (in Control ROM).  With no branches, (CD=0, MAP=0, CRJA = address of next instruction in routine) Last micro-instruction in the fetch routine should have map=1 to take an instruction from the address ROM The last micro-instruction in a routine should have 00000(binary) as its CRJA field, CD=0, MAP=0 branching back to the fetch micro-routine.    Table 4 A micro-program (set of all micro-routines) that implements described instruction set from When loaded into Control ROM\n  Microroutine Name (Mnemonic) The functional shortened name of each operation specified by the op-codes (Load Accumulator = LDA = 1) Used in assembly programming.\nColumns Micro-Instruction Address to Address of Next Micro-Instruction When taken together, forms the raw contents (changing hexadecimal to binary) of the Micro Control ROM\n   Address-ROM Address (Op-code)\ninput of instruction from external computer that is equivalent to first address of Micro-instruction in micro-routine.\n     Micro-Instruction Address\nMicro-Instruction addresses (2 bits) listed sequentially as part of a micro-routine\n LDA micro-routine = Opcode 1  03 04 05         Control Signal Field\nSame order of signals (bits) as the in Table 2 bits are equivalent to signals which are equivalent to pins.\n     CD\nConditional bit, when 1 causes multiplexer to depend on value of NF if MAP bit is 0\n     MAP\nWhen MAP bit is 1, multiplexer sends address of the first Micro-Instruction for the next micro-routine\n     Halt\nWhen HLT bit is 1, the Micro-Instruction Register will trigger the HALT signal, stopping the clock.\n     Address of Next micro-instruction\nOnly matters if HLT and MAP are not 1 (arbitrary values). The Micro-Instruction Address of the next Micro-Instruction in a non-branching program. Refer to description of Figure 8 for more explanation.\n  Comment This column provides a simple explanation for what happens in the micro-programmable control unit after each Micro-Instruction.\nFetch micro-routine  Control ROM addresses 0, 1, 2 (3 Micro-Instructions)  Micro-Instruction 0  Activates control Signal bits EP, LM Moves data from the Program Counter Register to the Memory Access Register MAR now contains address in RAM of the next instruction CD and MAP bits are zero, next Micro-Instruction corresponds to the address in the CRJA field (Micro-Instruction 1)   Micro-Instruction 1  Activates control Signal bit R Reads the data at adress MAR into Memory Data Register from RAM CD and MAP bits are zero, use CRJA field again (Micro-Instruction 2)   Micro-Instruction 2  Activates control Signal bits ED, LI, IP ED, LI moves the Word from MDR to the Instruction Register IP increments the PC Register New instruction is in IR PC now points to the next instruction MAP is now 1, so the next micro-instruction is from Address ROM (specified by op-code)   Signal pin description is in Figure 1    JN micro-routine  Control ROM addresses 0F, 10, 11  Micro-Instruction 0F  Does nothing except set the CD bit to 1 Execution of the next micro-instruction now depends on value of Negative Flag If NF is 0, increments Micro Program counter 0F + 1 = 10, Micro-Instruction 10 If NF is 1, uses CRJA field (Micro-Instruction 11)   Micro-Instruction 10  Does nothing (no set signal bits) MAP, CD = 0, uses CRJA field (Micro-Instruction 00 (Fetch routine)) PC is not altered, so next instruction is executed normally   Micro-Instruction 11  Activates Control Signal Bits EI, LP Moves contents of IR(least significan eight bits) to PC Next Instruction at location corresponding to value of the least significant 8 bits of IR Control of the computer is transferred to the \u0026ldquo;Jump address\u0026rdquo;      Hard-Wired vs. Micro-programmed Computers  Large majority of computers today are micro-programmed Micro-programmed computers are much more flexible you don\u0026rsquo;t have to make a new computer to change instruction set, only alter Control ROM Changing the firmware is the same as changing the contents of the Control ROM Hard-Wired architecture can not be easily(almost impossible) changed New architecture has do be designed at the hardware level (can\u0026rsquo;t add new instructions easily) Hard-Wired computers are faster (micro-program doesn\u0026rsquo;t have to react to input) and can be easier to manufacture (cheaper).  Old figures "
},
{
	"uri": "https://illustratedman-code.github.io/GuideToCS/",
	"title": "Home",
	"tags": [],
	"description": "",
	"content": "This is The home page\nHello "
},
{
	"uri": "https://illustratedman-code.github.io/GuideToCS/intro-to-comp-systems/how-to-write-a-micro-instruction/",
	"title": "How to write a micro-instruction",
	"tags": [],
	"description": "",
	"content": "A micro-instruction is just a binary (often converted to hex) number that represents a list of control signals, and points to the next micro-instruction. Micro-instructions can be changed by changing the A set of micro-instructions forms a micro-routine (otherwise known as an instruction).\nControl signals To understand the micro-instruction, you must understand what the control signals do. I will be referencing the Hard vs Micro paper. It has LA (load accumulator), and EA (enable accumulator) signals. They are essentially just wires connected to the control unit (referenced by the 16 coming out of CONTROL) Each register also generally has a clock signal (CLK), but that is connected directly to the clock circuit and is not required for the micro-instructions. The naming system for the signals is somewhat arbitrary but usually follows the pattern (L, E) (register). This is subverted somewhat by the ALU, but that will most likely be directly defined. The other main difference is the inclusion of I, which just means increment.\nLoad (L) A load signal allows the contents of a register to be changed by the state of the bus (a collection of wires). This signal must be paired with an E signal to do anything.\nEnable (E) An enable signal changes the state of the bus to match the contents of the register. Say a register contains the value 1111, when the enable signal is used for that register, the contents of the bus will now be 1111. This signal must be paired with a L signal to do anything.\nMicro-instructions A micro-instruction is a binary number composed of several fields stored at a specific address in the ROM (read only memory) of the control unit.\nControl field This is just a binary representation of the signals. In the hard vs micro document, the letters are signals are abbreviated into the following order:\n ILELAWLELELEASEL Expanded: IP LP EP LM R W LD ED LI EI LA EA A S E  A micro instruction will generally contain a pair of signals (L E) that transfers the contents of one register into another. The contents of the enabled register moves into the loaded register through the bus. A 1 means that the signal is on while a 0 means the signal is off.\nNext Address field This field has 4 different sub fields. it is used to determine the next micro instruction.\nCD CD (short for condition) is used for conditional logic. This bit makes the next micro-instruction depend on the value of the negative flag. This is generally off, unless you want conditional logic, see JN micro-routine\nMAP the map bit uses the next micro-instruction in the control ROM, see Fetch-routine . This is generally off.\nCRJA field This field consists of an address in the control ROM\nLDA micro-routine Here is a step by step on how to write this instruction with micro-instructions.\n Find out where the data is coming from. Map out the sub-steps:  IR -\u0026gt; MAR RAM -\u0026gt; MDR MDR -\u0026gt; ACC   determine the signals for each substep:  EI, LM R ED, LA   Link the micro-instructions with the next address field.  address of next micro-instruction (04) in this case address of next micro-instruction (05) in this case link back to fetch (00) in this case   Write the codes!  (0001000001000000)(0)(0)(0)(0100) (0000010000000000)(0)(0)(0)(0101) (0000000010010000)(0)(0)(0)(0000)   Optional convert to hex  82004 20005 4800    "
},
{
	"uri": "https://illustratedman-code.github.io/GuideToCS/intro-to-comp-systems/",
	"title": "Intro To Comp Systems",
	"tags": [],
	"description": "",
	"content": "Intro to comp systems as taught by Nitin.\n"
},
{
	"uri": "https://illustratedman-code.github.io/GuideToCS/intro-to-comp-systems/mock-exam-questions/",
	"title": "Mock Exam Questions",
	"tags": [],
	"description": "",
	"content": "Question 1 and 2 seem to reference this article: 8086-8088\nQ1 If a physical branch target address is 5A230 when CS = 5200, what will it be if the CS = 7800 ?\n We need to find the offset, where offset + CS(shifted 4 bits) = physical branch target address. CS(C segment register) Offset = Physical branch target address - CS Offset = 5A230 - 52000 = 8230 (hex)  The offset is then used to find the physical branch target adress.\n 78000 + 8230 = 80230 = physical branch target address  Q2 Given that the EA of a data is 2359 and DS = 490B, what is the PA of data?\n EA (effective Address), DS (D segment register), PA(Physical Address).  Physical address is given by EA + DS(shifted 4 bits).\n DS = 490B0 (hex) EA = 2359 (hex) PA = 490B0 + 2359 = 4B409  Q3 Assuming, W, X, Y and Z as memory addresses. Write a program using any machine sequence that will carry out the following: Z ← W + (Z-X).\n.globl main .text main: lw $t1, Z #load z into temporary register 1 lw $t2, X #load x into temporary register 2 sub $s1, $t1, $t2 #s1 \u0026lt;- t1-t2 lw $t1, W #load w into temporary register 1 add $s1, $t1, $s1 #s1 \u0026lt;- t1 sw $s1, Z # stores s1 into Z li $v0, 1 #prints z lw $a0, Z syscall li $v0, 10 #exits syscall Z: .word 12 #arbitrary value X: .word 10 #arbitrary value W: .word 5 #arbitrary value Downloadable solution prints 7\nQ4 Assume that the code below is run on a machine with a 2 GHz clock that requires the following number of cycles for each instruction: add, addi, sll, sra take 4cc each, lw takes 5cc, bne, beq take 3cc each. How many seconds will it take to execute this code. The values of registers are $4=0x20, $5= 0x20, $6= 0x30, $7= 0x10.\n.globl main .text main: sra $6, $6, 2 # changes original value of 0x30 / 2^2 = 0xC sll $7, $7, 2 # original value = 0x10, 0x10 * 2^2 = 0x40 add $8, $0, $0 # sets register 8 to 0 L2: add $12, $4, $8 #marks L2, $12 \u0026lt;- 0x20 + $8, $8 is iterator lw $12, 0($12) # $12 = memory at address of ($12) on stack add $9, $0, $0 # $9 = 0; L1: add $11, $5, $9 #marks L1, $11 = 0x20 + $9, $9 is iterator lw $11, 0($11) #$11 = memory at address of ($11) on stack addi $9, $9, 4 #$9 = $9 + 4 bne $9, $7, L1 # goes to L1 if $9 != $7 0x0 + 0x4 * 0x10 = 0x40 = $9 loop executes 0x10 times addi $8, $8, 4 # $8 = $8 + 4 beq $8, $6, L2 # goes to L2 if $8 == $6 exits before $8 can equal $6 Instruction definitions  sra (shift right arithmetic) (sra destination, origin, shift(in bits)) rounds down sll (shift left logical) (sll destination, origin, shift) bne (bne r1, r2, branch address) goes to branch address if r1 != r2 beq (beq, r1, r2, branch address) goest to branch address if r1 == r2  Calculate number of clock cycles Before loops  sra 4cc sll 4cc add 4cc total = 12cc  L2  add 4cc lw 5cc add 4cc L1 clocks addi 4cc beq 3cc total = (20cc + L1 clocks)*1 loop  L3  add 4cc lw 5cc addi 4ccc bne 3cc total = (16cc * 16 loops) = 256 clocks  Total clocks 12cc + 20cc + 256cc = 288cc\nCalculate time 288cc/(2*10^9cc/s) = 1.44 * 10^-7 seconds\nQ5 X[i] = A[B[i]] + C[i+4]\n starting address of A in $1 starting address of B in $2 starting address of C in $3 starting address of X in $4 i value in register $5  Q5 Solution download\n.globl main .text main: sll $s4, $5, 2 # multiplies i * 4 to conform to address form add $t2, $2, $s4 # gets address of B[i] offsets address of B by i lw $t3, ($t2) # sets t3 to value at address t3 = B[i] sll $t1, $t3, 2 # sets t1 to t3 * 4 to conform to address form add $t2, $1, $t1 # offsets addres value in $1 by $t1 A[B[i]] lw $s1, ($t2) # sets t3 to value at address $t2 t3 = A[B[i]] addi $t1, $5, 4 # offsets i by 4 = i+4 sll $t1, $5, 2 # multiplies i*4 to conform to address form add $t2, $3, $t1 # offsets C address by i+4 lw $s2, ($t2) # s2 = C[i+4] add $t1, $s1, $s2 # adds A[B[i]] + C[i+4] add $s3, $4, $s4 # offsets address of X by i sw $t1, ($s3) # stores $t1 to address of ($s3) Q6 The memory units that follow are specified by the number of words times the number of bits per word. How many address lines and input/output data lines are needed in each case? (a) 8K X 16 (b) 2G X 8 (c) 16M X 32 (d) 256K X 64\nPart A  Number of words = 8K Number of bits per word = 16 log base 2 of words = address lines 2^3 * 2^10 = 2^11 = 13 address lines I/O lines = address lines + bits per word 13 + 16 = 29 I/O lines  Part B  2^1 * 2^30 = 2G Address lines = 31 I/O lines = 31 + 8 = 39 39 I/O lines  Part C  2^4 * 2^20 = 16M Address lines = 24 I/O lines = 24 + 32 = 56 56 I/O lines  Part D  2^8 * 2^10 = 256K Address lines = 18 I/O lines = 18 + 64 82 I/O lines  TODO Q7 Find the number of bytes that can be stored in the memories: (a) 8K X 16 (b) 2G X 8 (c) 16M X 32 (d) 256K X 64\nPart A  8 bits per byte 8K words 16 bits per word number of bits = 8K*16 = 2^13 * 2^4 = 2^17 number of bytes = 2^17/2^3 = 2^14 = 16K bytes  Part B  Number of bits = 2G*8 = 2^31*2^3 Number of bytes = 2^31*2^3/2^3 = 2^31 = 2G bytes  Part C  Number of bytes = 16M * 32 / 2^3 = 2^24 * 32 /2^3 = 2^25 = 32M bytes  Part D  Number of bytes = 256K*64/2^3 = 2^18 * 64 /2^3 = 2^24 /2^3 = 2^21 = 2M bytes  TODO Q8 *\nTODO Q9 Given a 32 x 8 ROM chip with an enable input, show the external connections necessary to construct a 128 x 8 ROM with four chips and a decoder. Useful Video\n 2^5 = 32 5 address lines for each ROM 128/32 = 4 chips 4 outputs on decoder (connected to enable inputs) 2^2 = 4 2 address lines for the decoder 5 + 2 = 7 total lines for complete address    TODO Q10 "
}]